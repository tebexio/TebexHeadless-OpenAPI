/*
Tebex Headless API

The headless API is designed for implementing your own store frontend with the data of your store. You are able to call the Headless API directly from a web browser (such as within an SPA), or from a backend server, such as for in-game GUIs.

API version: 1.0.0
Contact: tebex-integrations@overwolf.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package TebexHeadless

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// HeadlessAPIService HeadlessAPI service
type HeadlessAPIService service

type ApiAddBasketPackageRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	basketIdent string
	addBasketPackageRequest *AddBasketPackageRequest
}

func (r ApiAddBasketPackageRequest) AddBasketPackageRequest(addBasketPackageRequest AddBasketPackageRequest) ApiAddBasketPackageRequest {
	r.addBasketPackageRequest = &addBasketPackageRequest
	return r
}

func (r ApiAddBasketPackageRequest) Execute() (*Basket, *http.Response, error) {
	return r.ApiService.AddBasketPackageExecute(r)
}

/*
AddBasketPackage Add a package to a basket

Add a package with the given ID to the basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param basketIdent The basket identifier.
 @return ApiAddBasketPackageRequest
*/
func (a *HeadlessAPIService) AddBasketPackage(ctx context.Context, basketIdent string) ApiAddBasketPackageRequest {
	return ApiAddBasketPackageRequest{
		ApiService: a,
		ctx: ctx,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return Basket
func (a *HeadlessAPIService) AddBasketPackageExecute(r ApiAddBasketPackageRequest) (*Basket, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Basket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.AddBasketPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/baskets/{basketIdent}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addBasketPackageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyCouponRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	coupon *Coupon
}

// Provide a &#x60;coupon_code&#x60; to apply to the basket.
func (r ApiApplyCouponRequest) Coupon(coupon Coupon) ApiApplyCouponRequest {
	r.coupon = &coupon
	return r
}

func (r ApiApplyCouponRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.ApplyCouponExecute(r)
}

/*
ApplyCoupon Apply a coupon to a basket.

Applies a creator code to a basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiApplyCouponRequest
*/
func (a *HeadlessAPIService) ApplyCoupon(ctx context.Context, token string, basketIdent string) ApiApplyCouponRequest {
	return ApiApplyCouponRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) ApplyCouponExecute(r ApiApplyCouponRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.ApplyCoupon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coupon
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyCreatorCodeRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	applyCreatorCodeRequest *ApplyCreatorCodeRequest
}

// Provide a &#x60;creator_code&#x60; to apply to the basket.
func (r ApiApplyCreatorCodeRequest) ApplyCreatorCodeRequest(applyCreatorCodeRequest ApplyCreatorCodeRequest) ApiApplyCreatorCodeRequest {
	r.applyCreatorCodeRequest = &applyCreatorCodeRequest
	return r
}

func (r ApiApplyCreatorCodeRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.ApplyCreatorCodeExecute(r)
}

/*
ApplyCreatorCode Apply a creator code to a basket.

Applies a creator code to a basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiApplyCreatorCodeRequest
*/
func (a *HeadlessAPIService) ApplyCreatorCode(ctx context.Context, token string, basketIdent string) ApiApplyCreatorCodeRequest {
	return ApiApplyCreatorCodeRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) ApplyCreatorCodeExecute(r ApiApplyCreatorCodeRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.ApplyCreatorCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/creator-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyCreatorCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyGiftCardRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	giftCard *GiftCard
}

// Provide a &#x60;card_number&#x60; to apply to the basket.
func (r ApiApplyGiftCardRequest) GiftCard(giftCard GiftCard) ApiApplyGiftCardRequest {
	r.giftCard = &giftCard
	return r
}

func (r ApiApplyGiftCardRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.ApplyGiftCardExecute(r)
}

/*
ApplyGiftCard Apply a gift card to a basket.

Applies a creator code to a basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiApplyGiftCardRequest
*/
func (a *HeadlessAPIService) ApplyGiftCard(ctx context.Context, token string, basketIdent string) ApiApplyGiftCardRequest {
	return ApiApplyGiftCardRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) ApplyGiftCardExecute(r ApiApplyGiftCardRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.ApplyGiftCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/giftcards"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.giftCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBasketRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	createBasketRequest *CreateBasketRequest
}

func (r ApiCreateBasketRequest) CreateBasketRequest(createBasketRequest CreateBasketRequest) ApiCreateBasketRequest {
	r.createBasketRequest = &createBasketRequest
	return r
}

func (r ApiCreateBasketRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.CreateBasketExecute(r)
}

/*
CreateBasket Create a new basket

Creates a new basket for use during checkout.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiCreateBasketRequest
*/
func (a *HeadlessAPIService) CreateBasket(ctx context.Context, token string) ApiCreateBasketRequest {
	return ApiCreateBasketRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) CreateBasketExecute(r ApiCreateBasketRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.CreateBasket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBasketRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllCategoriesRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
}

func (r ApiGetAllCategoriesRequest) Execute() (*CategoryResponse, *http.Response, error) {
	return r.ApiService.GetAllCategoriesExecute(r)
}

/*
GetAllCategories Gets all categories available in the webstore.

Gets all categories from a webstore. This does not include package information. To include package information, add `?includePackages=1` to the URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiGetAllCategoriesRequest
*/
func (a *HeadlessAPIService) GetAllCategories(ctx context.Context, token string) ApiGetAllCategoriesRequest {
	return ApiGetAllCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return CategoryResponse
func (a *HeadlessAPIService) GetAllCategoriesExecute(r ApiGetAllCategoriesRequest) (*CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/categories"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllCategoriesIncludingPackagesRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
}

func (r ApiGetAllCategoriesIncludingPackagesRequest) Execute() (*CategoryResponse, *http.Response, error) {
	return r.ApiService.GetAllCategoriesIncludingPackagesExecute(r)
}

/*
GetAllCategoriesIncludingPackages Gets a store's categories including all package information with them.

Gets all categories from a webstore including packages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiGetAllCategoriesIncludingPackagesRequest
*/
func (a *HeadlessAPIService) GetAllCategoriesIncludingPackages(ctx context.Context, token string) ApiGetAllCategoriesIncludingPackagesRequest {
	return ApiGetAllCategoriesIncludingPackagesRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return CategoryResponse
func (a *HeadlessAPIService) GetAllCategoriesIncludingPackagesExecute(r ApiGetAllCategoriesIncludingPackagesRequest) (*CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllCategoriesIncludingPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/categories?includePackages=1"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPackagesRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
}

func (r ApiGetAllPackagesRequest) Execute() (*PackageResponse, *http.Response, error) {
	return r.ApiService.GetAllPackagesExecute(r)
}

/*
GetAllPackages Fetch all packages from a webstore

Gets all packages from a webstore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiGetAllPackagesRequest
*/
func (a *HeadlessAPIService) GetAllPackages(ctx context.Context, token string) ApiGetAllPackagesRequest {
	return ApiGetAllPackagesRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PackageResponse
func (a *HeadlessAPIService) GetAllPackagesExecute(r ApiGetAllPackagesRequest) (*PackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPackagesWithAuthedIPRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	ipAddress string
}

func (r ApiGetAllPackagesWithAuthedIPRequest) Execute() (*PackageResponse, *http.Response, error) {
	return r.ApiService.GetAllPackagesWithAuthedIPExecute(r)
}

/*
GetAllPackagesWithAuthedIP Fetch a package from a webstore by its identifier

Gets all packages from a webstore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param ipAddress An IP address can be provided with authenticated requests.
 @return ApiGetAllPackagesWithAuthedIPRequest
*/
func (a *HeadlessAPIService) GetAllPackagesWithAuthedIP(ctx context.Context, token string, ipAddress string) ApiGetAllPackagesWithAuthedIPRequest {
	return ApiGetAllPackagesWithAuthedIPRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		ipAddress: ipAddress,
	}
}

// Execute executes the request
//  @return PackageResponse
func (a *HeadlessAPIService) GetAllPackagesWithAuthedIPExecute(r ApiGetAllPackagesWithAuthedIPRequest) (*PackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllPackagesWithAuthedIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/packages?ipAddress={ipAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipAddress"+"}", url.PathEscape(parameterValueToString(r.ipAddress, "ipAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPackagesWithAuthedIPAndBasketRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	ipAddress string
}

func (r ApiGetAllPackagesWithAuthedIPAndBasketRequest) Execute() (*PackageResponse, *http.Response, error) {
	return r.ApiService.GetAllPackagesWithAuthedIPAndBasketExecute(r)
}

/*
GetAllPackagesWithAuthedIPAndBasket Fetch a package from a webstore by its identifier

Gets all packages from a webstore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @param ipAddress An IP address can be provided with authenticated requests.
 @return ApiGetAllPackagesWithAuthedIPAndBasketRequest
*/
func (a *HeadlessAPIService) GetAllPackagesWithAuthedIPAndBasket(ctx context.Context, token string, basketIdent string, ipAddress string) ApiGetAllPackagesWithAuthedIPAndBasketRequest {
	return ApiGetAllPackagesWithAuthedIPAndBasketRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
		ipAddress: ipAddress,
	}
}

// Execute executes the request
//  @return PackageResponse
func (a *HeadlessAPIService) GetAllPackagesWithAuthedIPAndBasketExecute(r ApiGetAllPackagesWithAuthedIPAndBasketRequest) (*PackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllPackagesWithAuthedIPAndBasket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/packages?ipAddress={ipAddress}&basketIdent={basketIdent}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipAddress"+"}", url.PathEscape(parameterValueToString(r.ipAddress, "ipAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPackagesWithBasketRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
}

func (r ApiGetAllPackagesWithBasketRequest) Execute() (*PackageResponse, *http.Response, error) {
	return r.ApiService.GetAllPackagesWithBasketExecute(r)
}

/*
GetAllPackagesWithBasket Fetch a package from a webstore by its identifier

Gets all packages from a webstore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiGetAllPackagesWithBasketRequest
*/
func (a *HeadlessAPIService) GetAllPackagesWithBasket(ctx context.Context, token string, basketIdent string) ApiGetAllPackagesWithBasketRequest {
	return ApiGetAllPackagesWithBasketRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return PackageResponse
func (a *HeadlessAPIService) GetAllPackagesWithBasketExecute(r ApiGetAllPackagesWithBasketRequest) (*PackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetAllPackagesWithBasket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/packages?basketIdent={basketIdent}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBasketAuthUrlRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	returnUrl string
}

func (r ApiGetBasketAuthUrlRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.GetBasketAuthUrlExecute(r)
}

/*
GetBasketAuthUrl Fetch a basket from a webstore by its identifier

Fetches a basket's auth URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @param returnUrl The URL you would like to redirect the user to after successful basket authentication.
 @return ApiGetBasketAuthUrlRequest
*/
func (a *HeadlessAPIService) GetBasketAuthUrl(ctx context.Context, token string, basketIdent string, returnUrl string) ApiGetBasketAuthUrlRequest {
	return ApiGetBasketAuthUrlRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
		returnUrl: returnUrl,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) GetBasketAuthUrlExecute(r ApiGetBasketAuthUrlRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetBasketAuthUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/auth?returnUrl={returnUrl}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"returnUrl"+"}", url.PathEscape(parameterValueToString(r.returnUrl, "returnUrl")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBasketByIdRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
}

func (r ApiGetBasketByIdRequest) Execute() (*BasketResponse, *http.Response, error) {
	return r.ApiService.GetBasketByIdExecute(r)
}

/*
GetBasketById Fetch a basket from a webstore by its identifier

Gets a basket associated with the provided identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiGetBasketByIdRequest
*/
func (a *HeadlessAPIService) GetBasketById(ctx context.Context, token string, basketIdent string) ApiGetBasketByIdRequest {
	return ApiGetBasketByIdRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return BasketResponse
func (a *HeadlessAPIService) GetBasketByIdExecute(r ApiGetBasketByIdRequest) (*BasketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetBasketById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCMSPagesRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
}

func (r ApiGetCMSPagesRequest) Execute() (*CMSPagesResponse, *http.Response, error) {
	return r.ApiService.GetCMSPagesExecute(r)
}

/*
GetCMSPages Fetch the custom pages associated with the store.

Gets a list of custom pages associated with the webstore. These contain a `content` variable with the HTML content of the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiGetCMSPagesRequest
*/
func (a *HeadlessAPIService) GetCMSPages(ctx context.Context, token string) ApiGetCMSPagesRequest {
	return ApiGetCMSPagesRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return CMSPagesResponse
func (a *HeadlessAPIService) GetCMSPagesExecute(r ApiGetCMSPagesRequest) (*CMSPagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CMSPagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetCMSPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryByIdRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	categoryId string
}

func (r ApiGetCategoryByIdRequest) Execute() (*CategoryResponse, *http.Response, error) {
	return r.ApiService.GetCategoryByIdExecute(r)
}

/*
GetCategoryById Gets information about a specific category

Gets information about a category and returns the packages in that category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param categoryId The ID of the category to fetch.
 @return ApiGetCategoryByIdRequest
*/
func (a *HeadlessAPIService) GetCategoryById(ctx context.Context, token string, categoryId string) ApiGetCategoryByIdRequest {
	return ApiGetCategoryByIdRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return CategoryResponse
func (a *HeadlessAPIService) GetCategoryByIdExecute(r ApiGetCategoryByIdRequest) (*CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetCategoryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/categories/{categoryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"categoryId"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryIncludingPackagesRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	categoryId string
}

func (r ApiGetCategoryIncludingPackagesRequest) Execute() (*CategoryResponse, *http.Response, error) {
	return r.ApiService.GetCategoryIncludingPackagesExecute(r)
}

/*
GetCategoryIncludingPackages Gets information about a specific category, including all the packages in the category

Gets information about a category and returns the packages in that category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param categoryId The ID of the category to fetch.
 @return ApiGetCategoryIncludingPackagesRequest
*/
func (a *HeadlessAPIService) GetCategoryIncludingPackages(ctx context.Context, token string, categoryId string) ApiGetCategoryIncludingPackagesRequest {
	return ApiGetCategoryIncludingPackagesRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return CategoryResponse
func (a *HeadlessAPIService) GetCategoryIncludingPackagesExecute(r ApiGetCategoryIncludingPackagesRequest) (*CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetCategoryIncludingPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/categories/{categoryId}?includePackages=1"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"categoryId"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackageByIdRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	packageId float32
}

func (r ApiGetPackageByIdRequest) Execute() (*PackageResponse, *http.Response, error) {
	return r.ApiService.GetPackageByIdExecute(r)
}

/*
GetPackageById Fetch a package from a webstore by its identifier

Gets a package from a webstore by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param packageId The package's ID.
 @return ApiGetPackageByIdRequest
*/
func (a *HeadlessAPIService) GetPackageById(ctx context.Context, token string, packageId float32) ApiGetPackageByIdRequest {
	return ApiGetPackageByIdRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		packageId: packageId,
	}
}

// Execute executes the request
//  @return PackageResponse
func (a *HeadlessAPIService) GetPackageByIdExecute(r ApiGetPackageByIdRequest) (*PackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetPackageById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/packages/{packageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageId"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebstoreByIdRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
}

func (r ApiGetWebstoreByIdRequest) Execute() (*WebstoreResponse, *http.Response, error) {
	return r.ApiService.GetWebstoreByIdExecute(r)
}

/*
GetWebstoreById Fetch a webstore by its identifier

Gets the webstore associated with the provided identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @return ApiGetWebstoreByIdRequest
*/
func (a *HeadlessAPIService) GetWebstoreById(ctx context.Context, token string) ApiGetWebstoreByIdRequest {
	return ApiGetWebstoreByIdRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return WebstoreResponse
func (a *HeadlessAPIService) GetWebstoreByIdExecute(r ApiGetWebstoreByIdRequest) (*WebstoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebstoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.GetWebstoreById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveBasketPackageRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	basketIdent string
	removeBasketPackageRequest *RemoveBasketPackageRequest
}

func (r ApiRemoveBasketPackageRequest) RemoveBasketPackageRequest(removeBasketPackageRequest RemoveBasketPackageRequest) ApiRemoveBasketPackageRequest {
	r.removeBasketPackageRequest = &removeBasketPackageRequest
	return r
}

func (r ApiRemoveBasketPackageRequest) Execute() (*Basket, *http.Response, error) {
	return r.ApiService.RemoveBasketPackageExecute(r)
}

/*
RemoveBasketPackage Remove a package from a basket

Remove the given package ID from the basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param basketIdent The basket identifier.
 @return ApiRemoveBasketPackageRequest
*/
func (a *HeadlessAPIService) RemoveBasketPackage(ctx context.Context, basketIdent string) ApiRemoveBasketPackageRequest {
	return ApiRemoveBasketPackageRequest{
		ApiService: a,
		ctx: ctx,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
//  @return Basket
func (a *HeadlessAPIService) RemoveBasketPackageExecute(r ApiRemoveBasketPackageRequest) (*Basket, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Basket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.RemoveBasketPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/baskets/{basketIdent}/packages/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeBasketPackageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveCouponRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
}

func (r ApiRemoveCouponRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveCouponExecute(r)
}

/*
RemoveCoupon Remove a coupon from the basket.

Removes a coupon code from a basket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiRemoveCouponRequest
*/
func (a *HeadlessAPIService) RemoveCoupon(ctx context.Context, token string, basketIdent string) ApiRemoveCouponRequest {
	return ApiRemoveCouponRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
func (a *HeadlessAPIService) RemoveCouponExecute(r ApiRemoveCouponRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.RemoveCoupon")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/coupons/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveCreatorCodeRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
}

func (r ApiRemoveCreatorCodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveCreatorCodeExecute(r)
}

/*
RemoveCreatorCode Remove a creator code from the basket.

Applies a creator code to a basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiRemoveCreatorCodeRequest
*/
func (a *HeadlessAPIService) RemoveCreatorCode(ctx context.Context, token string, basketIdent string) ApiRemoveCreatorCodeRequest {
	return ApiRemoveCreatorCodeRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
func (a *HeadlessAPIService) RemoveCreatorCodeExecute(r ApiRemoveCreatorCodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.RemoveCreatorCode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/creator-codes/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveGiftCardRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	basketIdent string
	removeGiftCardRequest *RemoveGiftCardRequest
}

// Provide the &#x60;card_number&#x60; to remove from the basket.
func (r ApiRemoveGiftCardRequest) RemoveGiftCardRequest(removeGiftCardRequest RemoveGiftCardRequest) ApiRemoveGiftCardRequest {
	r.removeGiftCardRequest = &removeGiftCardRequest
	return r
}

func (r ApiRemoveGiftCardRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGiftCardExecute(r)
}

/*
RemoveGiftCard Remove a gift card from the basket.

Removes a gift card from the basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param basketIdent The basket identifier.
 @return ApiRemoveGiftCardRequest
*/
func (a *HeadlessAPIService) RemoveGiftCard(ctx context.Context, token string, basketIdent string) ApiRemoveGiftCardRequest {
	return ApiRemoveGiftCardRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		basketIdent: basketIdent,
	}
}

// Execute executes the request
func (a *HeadlessAPIService) RemoveGiftCardExecute(r ApiRemoveGiftCardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.RemoveGiftCard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/baskets/{basketIdent}/giftcards/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeGiftCardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePackageQuantityRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	basketIdent string
	packageId float32
	updatePackageQuantityRequest *UpdatePackageQuantityRequest
}

func (r ApiUpdatePackageQuantityRequest) UpdatePackageQuantityRequest(updatePackageQuantityRequest UpdatePackageQuantityRequest) ApiUpdatePackageQuantityRequest {
	r.updatePackageQuantityRequest = &updatePackageQuantityRequest
	return r
}

func (r ApiUpdatePackageQuantityRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePackageQuantityExecute(r)
}

/*
UpdatePackageQuantity Updates the quantity of the given package in the basket. The user must be logged in before the quantity can be changed.

Sets the quantity of the given item in the basket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param basketIdent The basket identifier.
 @param packageId The package identifier.
 @return ApiUpdatePackageQuantityRequest
*/
func (a *HeadlessAPIService) UpdatePackageQuantity(ctx context.Context, basketIdent string, packageId float32) ApiUpdatePackageQuantityRequest {
	return ApiUpdatePackageQuantityRequest{
		ApiService: a,
		ctx: ctx,
		basketIdent: basketIdent,
		packageId: packageId,
	}
}

// Execute executes the request
func (a *HeadlessAPIService) UpdatePackageQuantityExecute(r ApiUpdatePackageQuantityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.UpdatePackageQuantity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/baskets/{basketIdent}/packages/{packageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"basketIdent"+"}", url.PathEscape(parameterValueToString(r.basketIdent, "basketIdent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageId"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePackageQuantityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTierRequest struct {
	ctx context.Context
	ApiService *HeadlessAPIService
	token string
	tierId string
	updateTierRequest *UpdateTierRequest
}

func (r ApiUpdateTierRequest) UpdateTierRequest(updateTierRequest UpdateTierRequest) ApiUpdateTierRequest {
	r.updateTierRequest = &updateTierRequest
	return r
}

func (r ApiUpdateTierRequest) Execute() (*CMSPagesResponse, *http.Response, error) {
	return r.ApiService.UpdateTierExecute(r)
}

/*
UpdateTier TODO

Updates a tier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token The webstore identifier.
 @param tierId The tier identifier
 @return ApiUpdateTierRequest
*/
func (a *HeadlessAPIService) UpdateTier(ctx context.Context, token string, tierId string) ApiUpdateTierRequest {
	return ApiUpdateTierRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		tierId: tierId,
	}
}

// Execute executes the request
//  @return CMSPagesResponse
func (a *HeadlessAPIService) UpdateTierExecute(r ApiUpdateTierRequest) (*CMSPagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CMSPagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeadlessAPIService.UpdateTier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{token}/tiers/{tierId}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tierId"+"}", url.PathEscape(parameterValueToString(r.tierId, "tierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTierRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
